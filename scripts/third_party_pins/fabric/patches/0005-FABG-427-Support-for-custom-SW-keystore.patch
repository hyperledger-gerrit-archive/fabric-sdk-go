From 9d1350538a2db296f9127de5692fe9cee6eb74d7 Mon Sep 17 00:00:00 2001
From: Aleksandar Likic <aleksandar.likic@securekey.com>
Date: Mon, 3 Sep 2018 23:12:50 -0400
Subject: [PATCH] [FABG-427] Support for custom SW keystore

SW file keystore has been refactored to expose methods for
marshalling BCCSP keys to/from bytes. This allows one
to implement a custom keystore using the existing keystore
interface that accepts only BCCPS keys.

Change-Id: I88d4a883a5459c85d21df802efbf57680d7fc0b9
Signed-off-by: Aleksandar Likic <aleksandar.likic@securekey.com>
---
 bccsp/sw/fileks.go     | 125 ++++++++++---------------------------------------
 bccsp/sw/keymarshal.go | 121 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 147 insertions(+), 99 deletions(-)
 create mode 100644 bccsp/sw/keymarshal.go

diff --git a/bccsp/sw/fileks.go b/bccsp/sw/fileks.go
index 791ee3a72..9d4e11f6d 100644
--- a/bccsp/sw/fileks.go
+++ b/bccsp/sw/fileks.go
@@ -24,8 +24,6 @@ import (
 	"errors"
 	"strings"
 
-	"crypto/ecdsa"
-	"crypto/rsa"
 	"encoding/hex"
 	"fmt"
 	"path/filepath"
@@ -123,27 +121,20 @@ func (ks *fileBasedKeyStore) GetKey(ski []byte) (bccsp.Key, error) {
 	switch suffix {
 	case "key":
 		// Load the key
-		key, err := ks.loadKey(hex.EncodeToString(ski))
+		raw, err := ks.loadKey(hex.EncodeToString(ski))
 		if err != nil {
 			return nil, fmt.Errorf("Failed loading key [%x] [%s]", ski, err)
 		}
 
-		return &aesPrivateKey{key, false}, nil
+		return UnmarshalKey(raw, ks.pwd)
 	case "sk":
 		// Load the private key
-		key, err := ks.loadPrivateKey(hex.EncodeToString(ski))
+		raw, err := ks.loadPrivateKey(hex.EncodeToString(ski))
 		if err != nil {
 			return nil, fmt.Errorf("Failed loading secret key [%x] [%s]", ski, err)
 		}
 
-		switch key.(type) {
-		case *ecdsa.PrivateKey:
-			return &ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}, nil
-		case *rsa.PrivateKey:
-			return &rsaPrivateKey{key.(*rsa.PrivateKey)}, nil
-		default:
-			return nil, errors.New("Secret key type not recognized")
-		}
+		return UnmarshalPrivateKey(raw, ks.pwd)
 	case "pk":
 		// Load the public key
 		key, err := ks.loadPublicKey(hex.EncodeToString(ski))
@@ -151,14 +142,7 @@ func (ks *fileBasedKeyStore) GetKey(ski []byte) (bccsp.Key, error) {
 			return nil, fmt.Errorf("Failed loading public key [%x] [%s]", ski, err)
 		}
 
-		switch key.(type) {
-		case *ecdsa.PublicKey:
-			return &ecdsaPublicKey{key.(*ecdsa.PublicKey)}, nil
-		case *rsa.PublicKey:
-			return &rsaPublicKey{key.(*rsa.PublicKey)}, nil
-		default:
-			return nil, errors.New("Public key type not recognized")
-		}
+		return UnmarshalPublicKey(key, ks.pwd)
 	default:
 		return ks.searchKeystoreForSKI(ski)
 	}
@@ -171,46 +155,37 @@ func (ks *fileBasedKeyStore) StoreKey(k bccsp.Key) (err error) {
 		return errors.New("Read only KeyStore.")
 	}
 
-	if k == nil {
-		return errors.New("Invalid key. It must be different from nil.")
+	raw, err := MarshalKey(k, ks.pwd)
+	if err != nil {
+		return err
 	}
 	switch k.(type) {
 	case *ecdsaPrivateKey:
-		kk := k.(*ecdsaPrivateKey)
-
-		err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)
+		err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), raw)
 		if err != nil {
 			return fmt.Errorf("Failed storing ECDSA private key [%s]", err)
 		}
 
 	case *ecdsaPublicKey:
-		kk := k.(*ecdsaPublicKey)
-
-		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)
+		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), raw)
 		if err != nil {
 			return fmt.Errorf("Failed storing ECDSA public key [%s]", err)
 		}
 
 	case *rsaPrivateKey:
-		kk := k.(*rsaPrivateKey)
-
-		err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)
+		err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), raw)
 		if err != nil {
 			return fmt.Errorf("Failed storing RSA private key [%s]", err)
 		}
 
 	case *rsaPublicKey:
-		kk := k.(*rsaPublicKey)
-
-		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)
+		err = ks.storePublicKey(hex.EncodeToString(k.SKI()), raw)
 		if err != nil {
 			return fmt.Errorf("Failed storing RSA public key [%s]", err)
 		}
 
 	case *aesPrivateKey:
-		kk := k.(*aesPrivateKey)
-
-		err = ks.storeKey(hex.EncodeToString(k.SKI()), kk.privKey)
+		err = ks.storeKey(hex.EncodeToString(k.SKI()), raw)
 		if err != nil {
 			return fmt.Errorf("Failed storing AES key [%s]", err)
 		}
@@ -239,18 +214,9 @@ func (ks *fileBasedKeyStore) searchKeystoreForSKI(ski []byte) (k bccsp.Key, err
 			continue
 		}
 
-		key, err := utils.PEMtoPrivateKey(raw, ks.pwd)
+		k, err = UnmarshalPrivateKey(raw, ks.pwd)
 		if err != nil {
-			continue
-		}
-
-		switch key.(type) {
-		case *ecdsa.PrivateKey:
-			k = &ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}
-		case *rsa.PrivateKey:
-			k = &rsaPrivateKey{key.(*rsa.PrivateKey)}
-		default:
-			continue
+			return nil, err
 		}
 
 		if !bytes.Equal(k.SKI(), ski) {
@@ -281,14 +247,8 @@ func (ks *fileBasedKeyStore) getSuffix(alias string) string {
 	return ""
 }
 
-func (ks *fileBasedKeyStore) storePrivateKey(alias string, privateKey interface{}) error {
-	rawKey, err := utils.PrivateKeyToPEM(privateKey, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed converting private key to PEM [%s]: [%s]", alias, err)
-		return err
-	}
-
-	err = ioutil.WriteFile(ks.getPathForAlias(alias, "sk"), rawKey, 0600)
+func (ks *fileBasedKeyStore) storePrivateKey(alias string, rawKey []byte) error {
+	err := ioutil.WriteFile(ks.getPathForAlias(alias, "sk"), rawKey, 0600)
 	if err != nil {
 		logger.Errorf("Failed storing private key [%s]: [%s]", alias, err)
 		return err
@@ -297,14 +257,8 @@ func (ks *fileBasedKeyStore) storePrivateKey(alias string, privateKey interface{
 	return nil
 }
 
-func (ks *fileBasedKeyStore) storePublicKey(alias string, publicKey interface{}) error {
-	rawKey, err := utils.PublicKeyToPEM(publicKey, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed converting public key to PEM [%s]: [%s]", alias, err)
-		return err
-	}
-
-	err = ioutil.WriteFile(ks.getPathForAlias(alias, "pk"), rawKey, 0600)
+func (ks *fileBasedKeyStore) storePublicKey(alias string, rawKey []byte) error {
+	err := ioutil.WriteFile(ks.getPathForAlias(alias, "pk"), rawKey, 0600)
 	if err != nil {
 		logger.Errorf("Failed storing private key [%s]: [%s]", alias, err)
 		return err
@@ -313,14 +267,8 @@ func (ks *fileBasedKeyStore) storePublicKey(alias string, publicKey interface{})
 	return nil
 }
 
-func (ks *fileBasedKeyStore) storeKey(alias string, key []byte) error {
-	pem, err := utils.AEStoEncryptedPEM(key, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed converting key to PEM [%s]: [%s]", alias, err)
-		return err
-	}
-
-	err = ioutil.WriteFile(ks.getPathForAlias(alias, "key"), pem, 0600)
+func (ks *fileBasedKeyStore) storeKey(alias string, pem []byte) error {
+	err := ioutil.WriteFile(ks.getPathForAlias(alias, "key"), pem, 0600)
 	if err != nil {
 		logger.Errorf("Failed storing key [%s]: [%s]", alias, err)
 		return err
@@ -329,7 +277,7 @@ func (ks *fileBasedKeyStore) storeKey(alias string, key []byte) error {
 	return nil
 }
 
-func (ks *fileBasedKeyStore) loadPrivateKey(alias string) (interface{}, error) {
+func (ks *fileBasedKeyStore) loadPrivateKey(alias string) ([]byte, error) {
 	path := ks.getPathForAlias(alias, "sk")
 	logger.Debugf("Loading private key [%s] at [%s]...", alias, path)
 
@@ -340,17 +288,10 @@ func (ks *fileBasedKeyStore) loadPrivateKey(alias string) (interface{}, error) {
 		return nil, err
 	}
 
-	privateKey, err := utils.PEMtoPrivateKey(raw, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed parsing private key [%s]: [%s].", alias, err.Error())
-
-		return nil, err
-	}
-
-	return privateKey, nil
+	return raw, nil
 }
 
-func (ks *fileBasedKeyStore) loadPublicKey(alias string) (interface{}, error) {
+func (ks *fileBasedKeyStore) loadPublicKey(alias string) ([]byte, error) {
 	path := ks.getPathForAlias(alias, "pk")
 	logger.Debugf("Loading public key [%s] at [%s]...", alias, path)
 
@@ -361,14 +302,7 @@ func (ks *fileBasedKeyStore) loadPublicKey(alias string) (interface{}, error) {
 		return nil, err
 	}
 
-	privateKey, err := utils.PEMtoPublicKey(raw, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed parsing private key [%s]: [%s].", alias, err.Error())
-
-		return nil, err
-	}
-
-	return privateKey, nil
+	return raw, nil
 }
 
 func (ks *fileBasedKeyStore) loadKey(alias string) ([]byte, error) {
@@ -382,14 +316,7 @@ func (ks *fileBasedKeyStore) loadKey(alias string) ([]byte, error) {
 		return nil, err
 	}
 
-	key, err := utils.PEMtoAES(pem, ks.pwd)
-	if err != nil {
-		logger.Errorf("Failed parsing key [%s]: [%s]", alias, err)
-
-		return nil, err
-	}
-
-	return key, nil
+	return pem, nil
 }
 
 func (ks *fileBasedKeyStore) createKeyStoreIfNotExists() error {
diff --git a/bccsp/sw/keymarshal.go b/bccsp/sw/keymarshal.go
new file mode 100644
index 000000000..48675b8c8
--- /dev/null
+++ b/bccsp/sw/keymarshal.go
@@ -0,0 +1,121 @@
+/*
+Copyright SecureKey Technologies Inc. All Rights Reserved.
+
+SPDX-License-Identifier: Apache-2.0
+*/
+package sw
+
+import (
+	"errors"
+
+	"crypto/ecdsa"
+	"crypto/rsa"
+	"fmt"
+
+	"github.com/hyperledger/fabric/bccsp"
+	"github.com/hyperledger/fabric/bccsp/utils"
+)
+
+// MarshalKey marshals a BCCSP key to PEM format
+func MarshalKey(k bccsp.Key, pwd []byte) (raw []byte, err error) {
+	if k == nil {
+		return nil, errors.New("Invalid key. It must be different from nil.")
+	}
+	switch k.(type) {
+	case *ecdsaPrivateKey:
+		kk := k.(*ecdsaPrivateKey)
+
+		raw, err = utils.PrivateKeyToPEM(kk.privKey, pwd)
+		if err != nil {
+			logger.Errorf("Failed converting private key to PEM: [%s]", err)
+			return nil, err
+		}
+
+	case *ecdsaPublicKey:
+		kk := k.(*ecdsaPublicKey)
+
+		raw, err = utils.PublicKeyToPEM(kk.pubKey, pwd)
+		if err != nil {
+			logger.Errorf("Failed converting public key to PEM: [%s]", err)
+			return nil, err
+		}
+
+	case *rsaPrivateKey:
+		kk := k.(*rsaPrivateKey)
+
+		raw, err = utils.PrivateKeyToPEM(kk.privKey, pwd)
+		if err != nil {
+			logger.Errorf("Failed converting private key to PEM: [%s]", err)
+			return nil, err
+		}
+
+	case *rsaPublicKey:
+		kk := k.(*rsaPublicKey)
+
+		raw, err = utils.PublicKeyToPEM(kk.pubKey, pwd)
+		if err != nil {
+			logger.Errorf("Failed converting public key to PEM: [%s]", err)
+			return nil, err
+		}
+
+	case *aesPrivateKey:
+		kk := k.(*aesPrivateKey)
+
+		raw, err = utils.AEStoEncryptedPEM(kk.privKey, pwd)
+		if err != nil {
+			logger.Errorf("Failed converting key to PEM: [%s]", err)
+			return nil, err
+		}
+
+	default:
+		return nil, fmt.Errorf("Key type not reconigned [%s]", k)
+	}
+
+	return
+}
+
+// UnmarshalKey unmarshals a symetric AES BCCSP key from PEM format
+func UnmarshalKey(pem []byte, pwd []byte) (bccsp.Key, error) {
+	aes, err := utils.PEMtoAES(pem, pwd)
+	if err != nil {
+		logger.Errorf("Failed parsing key: [%s]", err)
+
+		return nil, err
+	}
+
+	return &aesPrivateKey{aes, false}, nil
+}
+
+// UnmarshalKey unmarshals a private BCCSP key from PEM format
+func UnmarshalPrivateKey(raw []byte, pwd []byte) (bccsp.Key, error) {
+	key, err := utils.PEMtoPrivateKey(raw, pwd)
+	if err != nil {
+		logger.Errorf("Failed parsing private key: [%s].", err.Error())
+		return nil, err
+	}
+	switch key.(type) {
+	case *ecdsa.PrivateKey:
+		return &ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}, nil
+	case *rsa.PrivateKey:
+		return &rsaPrivateKey{key.(*rsa.PrivateKey)}, nil
+	default:
+		return nil, errors.New("Secret key type not recognized")
+	}
+}
+
+// UnmarshalKey unmarshals a public BCCSP key from PEM format
+func UnmarshalPublicKey(raw []byte, pwd []byte) (bccsp.Key, error) {
+	key, err := utils.PEMtoPublicKey(raw, pwd)
+	if err != nil {
+		logger.Errorf("Failed parsing private key: [%s].", err.Error())
+		return nil, err
+	}
+	switch key.(type) {
+	case *ecdsa.PublicKey:
+		return &ecdsaPublicKey{key.(*ecdsa.PublicKey)}, nil
+	case *rsa.PublicKey:
+		return &rsaPublicKey{key.(*rsa.PublicKey)}, nil
+	default:
+		return nil, errors.New("Public key type not recognized")
+	}
+}
-- 
2.14.3 (Apple Git-98)

